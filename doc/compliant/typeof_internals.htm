<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./typeof_internals_files/filelist.xml">
<title>So, let’s say we have an expression “expr”</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vertleyb</o:Author>
  <o:LastAuthor>Vertleyb</o:LastAuthor>
  <o:Revision>24</o:Revision>
  <o:TotalTime>3449</o:TotalTime>
  <o:Created>2005-03-26T06:10:00Z</o:Created>
  <o:LastSaved>2005-04-30T14:53:00Z</o:LastSaved>
  <o:Pages>22</o:Pages>
  <o:Words>3359</o:Words>
  <o:Characters>19150</o:Characters>
  <o:Lines>159</o:Lines>
  <o:Paragraphs>38</o:Paragraphs>
  <o:CharactersWithSpaces>23517</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:View>Normal</w:View>
  <w:DrawingGridHorizontalSpacing>2.85 pt</w:DrawingGridHorizontalSpacing>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Arial Black";
	panose-1:2 11 10 4 2 1 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;}
h2
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:14.0pt;
	font-family:Arial;
	font-style:italic;}
h3
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:20.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";}
h4
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:4;
	font-size:18.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Arial Black";
	mso-bidi-font-family:Arial;
	font-weight:normal;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:24.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:48.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:60.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:84.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:96.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{mso-ascii-font-family:Arial;
	mso-hansi-font-family:Arial;
	mso-bidi-font-family:Arial;
	color:#0000CC;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p.Code, li.Code, div.Code
	{mso-style-name:Code;
	mso-style-update:auto;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	background:#E6E6E6;
	font-size:12.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
span.NewCode
	{mso-style-name:"New Code";
	mso-ansi-font-size:12.0pt;
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";
	color:navy;
	font-weight:bold;}
span.NewCode2
	{mso-style-name:"New Code 2";
	mso-style-parent:"New Code";
	mso-ansi-font-size:12.0pt;
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";
	color:red;
	font-weight:bold;}
span.NewCode3
	{mso-style-name:"New Code 3";
	mso-style-parent:"New Code";
	mso-ansi-font-size:12.0pt;
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";
	color:green;
	font-weight:bold;}
@page Section1
	{size:11.0in 8.5in;
	mso-page-orientation:landscape;
	margin:1.25in 1.0in 1.25in 1.0in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:2059626725;
	mso-list-type:hybrid;
	mso-list-template-ids:-1262348300 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l1
	{mso-list-id:2138839785;
	mso-list-type:hybrid;
	mso-list-template-ids:105941358 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l1:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link="#0000cc" vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoToc1><a name="_Toc100200535"><b><span style='font-size:20.0pt;
mso-bidi-font-size:12.0pt'>The TYPEOF internals</span></b></a><b><span
style='font-size:20.0pt;mso-bidi-font-size:12.0pt'><o:p></o:p></span></b></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><!--[if supportFields]><span
style='mso-element:field-begin'></span><span style="mso-spacerun:
yes"> </span>TOC \o &quot;1-3&quot; \h \z <span style='mso-element:field-separator'></span><![endif]--><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142297">Introduction<span
style='font-family:"Times New Roman";color:windowtext;display:none;mso-hide:
screen;text-decoration:none;text-underline:none'><span style='mso-tab-count:
1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142297 \\h"'>1<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003200390037000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142298">General
idea<span style='font-family:"Times New Roman";color:windowtext;display:none;
mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142298 \\h"'>2<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003200390038000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142299">Encoding
and decoding a type<span style='font-family:"Times New Roman";color:windowtext;
display:none;mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142299 \\h"'>4<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003200390039000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142300">Implementation<span
style='font-family:"Times New Roman";color:windowtext;display:none;mso-hide:
screen;text-decoration:none;text-underline:none'><span style='mso-tab-count:
1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142300 \\h"'>7<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300030000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142301">Encoding
and decoding templates<span style='font-family:"Times New Roman";color:windowtext;
display:none;mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142301 \\h"'>9<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300031000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142302">Different
kinds of template parameters or polymorphism with macros<span style='font-family:
"Times New Roman";color:windowtext;display:none;mso-hide:screen;text-decoration:
none;text-underline:none'><span style='mso-tab-count:1 dotted'>. </span><span
style='mso-field-code:"PAGEREF _Toc102142302 \\h"'>10<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300032000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142303">Template
template parameters<span style='font-family:"Times New Roman";color:windowtext;
display:none;mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142303 \\h"'>14<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300033000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142304">Handling
unused sequence elements<span style='font-family:"Times New Roman";color:windowtext;
display:none;mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142304 \\h"'>18<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300034000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 647.5pt'><span
class=MsoHyperlink><span style='font-family:Arial'><a href="#_Toc102142305">A
word about complexity<span style='font-family:"Times New Roman";color:windowtext;
display:none;mso-hide:screen;text-decoration:none;text-underline:none'><span
style='mso-tab-count:1 dotted'>. </span><span style='mso-field-code:"PAGEREF _Toc102142305 \\h"'>21<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003100300032003100340032003300300035000000</w:data>
</xml><![endif]--></span></span></a></span></span></p>

<p class=MsoToc1><!--[if supportFields]><span style='mso-element:field-end'></span><![endif]--><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1><a name="_Toc100200536"></a><a name="_Toc102142297"><span style='mso-bookmark:
_Toc100200536'>Introduction</span></a></h1>

<p class=MsoNormal>This document describes the internals of<span
style="mso-spacerun: yes">  </span>the TYPEOF macro implementation.<span
style="mso-spacerun: yes">  </span>It is related to so called “compliant”
implementation – one that uses partial template specializations to encode and
decode types, and is not to be confused with the other two implementations that
currently exist (or once existed) under the umbrella of the proposed
BOOST_TYPEOF macro – Peder Holt’s “vintage” implementation, that trades partial
template specialization for function overloading and compile time constants, as
well as recently invented by Igor Chesnokov MSVC-specific typeof trick.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The code in this document is provided <b>for the explanation
purpose only</b>.<span style="mso-spacerun: yes">  </span>While it does reflect
the actual code pretty closely, it differs in a number of ways.<span
style="mso-spacerun: yes">  </span>First, the BOOST_TYPEOF prefix has been
omitted from all the macros to make the code smaller.<span style="mso-spacerun:
yes">  </span>The namespaces have been omitted for the same reason.<span
style="mso-spacerun: yes">  </span>Second, the code fragments were entered by
hand, and were not compiled, so I apologize in advance for any typos made.<span
style="mso-spacerun: yes">  </span>I hope these typos will not prevent the
reader from understanding the material, but would be happy to correct them as
they are found and reported.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>It has to be stressed that the idea of breaking a type into
multiple compile-time integers by using partial template specializations is not
new, and belongs, to the best of my knowledge, to <b>Steve Dewhurst</b>, who
described it in his famous CUJ article “A BIT-Wise Typeof Operator”.<span
style="mso-spacerun: yes">  </span>The idea of applying MPL to this problem
belongs to <b>David Abrahams</b>, see <a
href="http://thread.gmane.org/gmane.comp.lib.boost.devel/76208"><span
style='mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>http://thread.gmane.org/gmane.comp.lib.boost.devel/76208</span></a>.<span
style="mso-spacerun: yes">  </span></p>

<p class=MsoToc1><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The main thing that distinguishes this implementation from
others available is the ease of definition of new specializations for
complicated templates.<span style="mso-spacerun: yes">  </span>For example:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T, int n, template&lt;class, unsigned int&gt;
class Tpl&gt; </p>

<p class=Code>class foo; /* a template with rather involved template id */</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>REGISTER_TEMPLATE(foo,
(class)(int)(TEMPLATE((class)(unsigned int))))</span> /* now foo can be handled
by TYPEOF */</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The implementation of this REGISTER_TEMPLATE macro, as well
as many other useful specializations (for functions, arrays, etc.), has become
possible because of extensive usage of the <b>Boost Preprocessor Library</b>.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><b>Peder Holt</b> deserves the most credit for support of
template template parameters (discussed later in this document).</p>

<h1><a name="_Toc100200537"></a><a name="_Toc102142298"><span style='mso-bookmark:
_Toc100200537'>General idea</span></a></h1>

<p class=MsoNormal>Let’s say we have an expression “expr”.<span
style="mso-spacerun: yes">  </span>The first step would be to pass it to a
function template, thus utilizing the built-in type deduction capabilities:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T&gt; </p>

<p class=Code><i>unspecified</i> foo(const T&amp;);</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>foo(expr);</p>

<p class=MsoNormal><span class=NewCode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></span></p>

<p class=MsoNormal>Inside foo() the type of the expression is known (T), so the
return type can be constructed in such a way that its size depends on the type
T.<span style="mso-spacerun: yes">  </span>One of possible ways of doing this
is to return a reference to a character array:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T&gt; </p>

<p class=Code><span class=NewCode>char(&amp;</span><b> </b>foo(const T&amp;) <span
class=NewCode>)[<o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span class=NewCode>integral-const-depends-on-T<o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span class=NewCode>]</span>;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>sizeof(</span><b> </b>foo(expr) <span
class=NewCode>)</span>;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Now let’s assume that a type can be encoded into a sequence
of integer numbers.<span style="mso-spacerun: yes">  </span>We will later
explore how to do this.<span style="mso-spacerun: yes">  </span>Let’s just say
for now that it can be done, and looks like following:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T&gt;</p>

<p class=Code>struct encode_type</p>

<p class=Code>{</p>

<p class=Code><span style='mso-tab-count:1'>     </span>typedef <i>unspecified</i>
type; // sequence of integer numbers</p>

<p class=Code>};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Since sizeof(foo(expr)) is just one integer, we cannot
handle the whole sequence.<span style="mso-spacerun: yes">  </span>Let’s then
return the Nth element of such sequence.<span style="mso-spacerun: yes"> 
</span>Accordingly, we add a parameter to “foo”, and rename it into more
descriptive “at”:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T<span class=NewCode>, class N</span>&gt; </p>

<p class=Code>char(&amp; <span class=NewCode>at</span>(const T&amp;<span
class=NewCode>, const N&amp;</span>) )[</p>

<p class=Code style='text-indent:.5in'><span class=NewCode>mpl::at&lt;encode_type&lt;T&gt;::type,
N&gt;::type::value<o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>We can now reconstruct the sequence like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>mpl::vector&lt;<o:p></o:p></span></p>

<p class=Code><span style='mso-tab-count:1'>     </span><span class=NewCode>mpl::int_&lt;</span>sizeof(at(expr,
mpl::int_&lt; <span class=NewCode>0 </span>&gt;()))<span class=NewCode>&gt;</span>,</p>

<p class=Code><span style='mso-tab-count:1'>     </span><span class=NewCode>mpl::int_&lt;</span>sizeof(at(expr,
mpl::int_&lt; <span class=NewCode>1 </span>&gt;()))<span class=NewCode>&gt;</span>,</p>

<p class=Code><span style='mso-tab-count:1'>     </span><span class=NewCode>mpl::int_&lt;</span>sizeof(at(expr,
mpl::int_&lt; <span class=NewCode>2 </span>&gt;()))<span class=NewCode>&gt;</span>,</p>

<p class=Code><span style='mso-tab-count:1'>     </span>…</p>

<p class=Code><span style='mso-tab-count:1'>     </span><span class=NewCode>mpl::int_&lt;</span>sizeof(at(expr,
mpl::int_&lt; <span class=NewCode>N </span>&gt;()))<span class=NewCode>&gt;</span></p>

<p class=Code><span class=NewCode>&gt;<o:p></o:p></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>If we take a big enough N, we can hope that our type will
fit.<span style="mso-spacerun: yes">  </span>We will also let alone for now the
issue of how unused elements are handled.<span style="mso-spacerun: yes"> 
</span>Assuming now that it’s possible to decode this into the original type,
we can write:<span class=NewCode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#define TYPEOF(expr)</span>\</p>

<p class=Code style='text-indent:.5in'><span class=NewCode>decode_type&lt;</span>mpl::vector&lt;\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;0&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;1&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;2&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>…\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;N&gt;()))&gt;\</p>

<p class=Code style='text-indent:.5in'>&gt; <span class=NewCode>&gt;::type</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Let’s understand where we are.<span style="mso-spacerun:
yes">  </span>We just implemented the simplified typeof facility assuming the
following:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:.25in;text-indent:-.25in;mso-list:l1 level1 lfo2;
tab-stops:list .25in'><![if !supportLists]>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>It’s possible to encode a type into a compile-time sequence of
integer numbers;</p>

<p class=MsoNormal style='margin-left:.25in;text-indent:-.25in;mso-list:l1 level1 lfo2;
tab-stops:list .25in'><![if !supportLists]>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>It’s possible to decode it back;</p>

<p class=MsoNormal style='margin-left:.25in;text-indent:-.25in;mso-list:l1 level1 lfo2;
tab-stops:list .25in'><![if !supportLists]>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>It’s possible to gracefully handle the unused elements of the
sequence.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Let’s now explore these three issues in more detail.</p>

<h1><a name="_Toc100200538"></a><a name="_Toc102142299"><span style='mso-bookmark:
_Toc100200538'>Encoding and decoding a type</span></a></h1>

<p class=MsoNormal>Let’s consider the following type:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>const std::pair&lt;int*, std::string&gt;*<span
style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>This type can be represented as a tree where each node is
either a type or a template or a modifier of the original type:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span style="mso-spacerun: yes">                            
</span><span style="mso-spacerun: yes">   </span>+-- <b>pointer</b> -- <b>int</b></p>

<p class=Code><b>pointer</b> -- <b>const</b> -- <b>std::pair</b> --+</p>

<p class=Code><span style="mso-spacerun: yes">                               
</span>+-- <b>std::string</b> </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Let’s assign unique integer identifiers like following:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>pointer<span style='mso-tab-count:2'>       </span>1</p>

<p class=Code>const<span style='mso-tab-count:2'>         </span>2</p>

<p class=Code>std::pair<span style='mso-tab-count:2'>     </span>3</p>

<p class=Code>int<span style='mso-tab-count:3'>           </span>4</p>

<p class=Code>std::string<span style='mso-tab-count:1'>   </span>5</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Now the above type can be encoded as:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>1 2 3 1 4 5</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Once identifiers are assigned, any type containing these
items can be encoded, such as:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<table border=1 cellspacing=0 cellpadding=0 width="100%" bgcolor=white
 style='width:100.0%;background:white;border-collapse:collapse;border:none;
 mso-border-alt:solid windowtext .5pt;mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td width="50%" valign=top style='width:50.0%;border:solid windowtext .5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>std::pair&lt;<br>
  <span style="mso-spacerun: yes">  </span>std::string, <br>
  <span style="mso-spacerun: yes">  </span>const std::string*<br>
  &gt;<o:p></o:p></span></p>
  </td>
  <td width="50%" valign=top style='width:50.0%;border:solid windowtext .5pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>3 5 1 2 5<o:p></o:p></span></p>
  </td>
 </tr>
 <tr>
  <td width="50%" valign=top style='width:50.0%;border:solid windowtext .5pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>const
  std::string* const<o:p></o:p></span></p>
  </td>
  <td width="50%" valign=top style='width:50.0%;border-top:none;border-left:
  none;border-bottom:solid windowtext .5pt;border-right:solid windowtext .5pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>2 1 2 5<o:p></o:p></span></p>
  </td>
 </tr>
 <tr>
  <td width="50%" valign=top style='width:50.0%;border:solid windowtext .5pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>std::pair&lt;<br>
  <span style="mso-spacerun: yes">  </span>std::pair&lt;int, int&gt;,<br>
  <span style="mso-spacerun: yes">  </span>std::pair&lt;std::string,
  std::string&gt; <br>
  &gt;<o:p></o:p></span></p>
  </td>
  <td width="50%" valign=top style='width:50.0%;border-top:none;border-left:
  none;border-bottom:solid windowtext .5pt;border-right:solid windowtext .5pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:
  6.0pt;margin-left:0in'><span style='font-family:"Courier New"'>3 3 4 4 3 5 5<o:p></o:p></span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Decoding is also simple.<span style="mso-spacerun: yes"> 
</span>Let’s decode the following sequence: 1 3 4 1 2 5</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>decode(1 3 4 1 2 5)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The first item, 1, tells us that this is a pointer:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>decode(3 4 1 2 5)*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>3 is an std::pair, and this is a template with two
parameters:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>std::pair&lt;decode-2(4 1 2 5)&gt;*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>4 is an integer: </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>std::pair&lt;int, decode(125)&gt;*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>1 is a pointer:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>std::pair&lt;int, decode(25)*&gt;*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>2 is const:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>std::pair&lt;int, const decode(5)*&gt;*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>5 is std::string:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>std::pair&lt;int, const std::string*&gt;*</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>We are done.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Having figured out how types can be encoded into a sequence
of integers, and then decoded back, let’s now see how this all can be
implemented.</p>

<h1><a name="_Toc100200539"></a><a name="_Toc102142300"><span style='mso-bookmark:
_Toc100200539'>Implementation</span></a></h1>

<p class=MsoNormal>The described type encoding can be implemented with partial
template specialization.<span style="mso-spacerun: yes">  </span>For now let’s
ignore the issue of generating unique identifiers.<span style="mso-spacerun:
yes">  </span>Let’s assume we have a UNIQUE_ID() macro that does the job.<span
style="mso-spacerun: yes">  </span>Also, from the compile-time performance
point of view, it makes sense to append the encoding to a given sequence (which
we’ll denote by “V” since this is an mpl::vector):</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class V, class T&gt; </p>

<p class=Code>struct encode_type; //not implemented</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>We can encode a type, for instance an integer, with the
following specialization:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class V&gt; </p>

<p class=Code>struct encode_type&lt;V, int&gt; : mpl::push_back&lt;</p>

<p class=Code style='text-indent:.5in'>V, </p>

<p class=Code style='text-indent:.5in'>mpl::int_&lt;4&gt; </p>

<p class=Code>&gt;</p>

<p class=Code>{};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>When decoding a type, we will accept an iterator into
original sequence, extract the first identifier, use it to match partial
template specialization, and forward the rest of the sequence to this
specialization:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class Iter&gt; </p>

<p class=Code>struct decode_type : decode_type_impl&lt;</p>

<p class=Code style='text-indent:.5in'>typename mpl::deref&lt;Iter&gt;::type, </p>

<p class=Code style='text-indent:.5in'>typename mpl::next&lt;Iter&gt;::type</p>

<p class=Code>&gt;</p>

<p class=Code>{};</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class ID, class Iter&gt; </p>

<p class=Code>struct decode_type_impl; //not implemented </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The implementation will return the decoded type and the
position into original sequence where the decoding stopped.<span
style="mso-spacerun: yes">  </span>Again, for integer, it will look like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class Iter&gt; </p>

<p class=Code>struct decode_type_impl&lt;mpl::int_&lt;4&gt;, Iter&gt;</p>

<p class=Code>{</p>

<p class=Code><span style='mso-tab-count:1'>     </span>typedef int type;</p>

<p class=Code><span style='mso-tab-count:1'>     </span>typedef Iter iter;</p>

<p class=Code>};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Both specializations for the same type can be combined into
a single macro:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#define REGISTER_TYPE_IMPL(Name, ID)</span><span
style="mso-spacerun: yes">             </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>template&lt;class
V&gt;<span style="mso-spacerun: yes">                              </span>\ </p>

<p class=Code><span style="mso-spacerun: yes">  </span>struct encode_type&lt;V,
<span class=NewCode>Name</span>&gt; : mpl::push_back&lt;<span
style="mso-spacerun: yes">  </span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>V,<span
style="mso-spacerun: yes">                   </span><span style="mso-spacerun:
yes">                        </span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>mpl::int_&lt;<span
class=NewCode>ID</span>&gt;<span style="mso-spacerun:
yes">                                </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;<span
style="mso-spacerun: yes">                                             
</span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>{};<span
style="mso-spacerun: yes">                                            </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>template&lt;class
Iter&gt;<span style="mso-spacerun: yes">                           </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>struct
decode_type_impl&lt;mpl::int_&lt;<span class=NewCode>ID</span>&gt;,
Iter&gt;<span style="mso-spacerun: yes">   </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>{<span
style="mso-spacerun: yes">                                             
</span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>typedef <span
class=NewCode>Name</span> type;<span style="mso-spacerun:
yes">                           </span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>typedef Iter
iter;<span style="mso-spacerun: yes">                           </span>\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>};</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#define REGISTER_TYPE(Name)\<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes"> 
</span>REGISTER_TYPE_IMPL(Name, UNIQUE_ID())</span></p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>REGISTER_TYPE(int)</p>

<p class=Code>REGISTER_TYPE(char)</p>

<p class=Code>REGISTER_TYPE(short)</p>

<p class=Code>REGISTER_TYPE(long)</p>

<p class=Code>...</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1><a name="_Toc100200540"></a><a name="_Toc102142301"><span style='mso-bookmark:
_Toc100200540'>Encoding and decoding templates</span></a></h1>

<p class=MsoNormal>Let’s consider std::pair class template.<span
style="mso-spacerun: yes">  </span>Its encoding will put its ID, 3, into the
vector, and then forward to encoding of its first, and then second template
parameter:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class V, class P0, class P1&gt; </p>

<p class=Code>struct encode_type&lt;V, std::pair&lt;P0, P1&gt; &gt;</p>

<p class=Code>{</p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef typename
mpl::push_back&lt;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>V, </p>

<p class=Code><span style="mso-spacerun: yes">    </span>mpl::int_&lt;3&gt; </p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;::type v0;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef typename
encode_type&lt;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>v0,</p>

<p class=Code><span style="mso-spacerun: yes">    </span>P0</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;::type v1;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef typename
encode_type&lt;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>v1,</p>

<p class=Code><span style="mso-spacerun: yes">    </span>P1</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;::type v2;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef v2 type;</p>

<p class=Code>};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Decoding will decode the parameters, and re-construct the
pair:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class Iter&gt; </p>

<p class=Code>struct decode_type_impl&lt;mpl::int_&lt;3&gt;, Iter&gt;</p>

<p class=Code>{</p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef
decode_type&lt;Iter&gt; d0;</p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef
decode_type&lt;typename d0::iter&gt; d1;</p>

<p class=Code><span style="mso-spacerun: yes">  </span></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef std::pair&lt;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>typename d0::type, </p>

<p class=Code><span style="mso-spacerun: yes">    </span>typename d1::type</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt; type;</p>

<p class=Code><span style="mso-spacerun: yes">  </span></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef typename
d1::iter iter; </p>

<p class=Code>};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>With a little bit of preprocessor magic, these two can be
combined into a single macro that can be used like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>REGISTER_TEMPLATE(std::pair, 2)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>This is all there is to say about templates as long as they
only have type parameters.<span style="mso-spacerun: yes">  </span>Things get
more interesting however once we get to consider integral and template template
parameters.</p>

<h1><a name="_Toc100200541"></a><a name="_Toc102142302"><span style='mso-bookmark:
_Toc100200541'>Different kinds of template parameters or polymorphism with
macros</span></a></h1>

<p class=MsoNormal>Let’s say we have the following class template:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T, unsigned int n&gt; class x;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>First, how do we describe such a template to the
preprocessor?<span style="mso-spacerun: yes">  </span>This can be done with a
preprocessor sequence:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>REGISTER_TEMPLATE(x, (<span class=NewCode>class</span>)(<span
class=NewCode2>unsigned int</span>))</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>(Note that this is the same REGISTER_TEMPLATE macro, only
now the second macro parameter describes what template parameters are used,
rather than just providing their number.<span style="mso-spacerun: yes"> 
</span>The macro is overloaded using some preprocessor magic.)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>We already discussed how a type template parameter is
encoded.<span style="mso-spacerun: yes">  </span>Simplifying things for the
purpose of clarity, we can assume that an integral template parameter is just
placed as is into the vector, although this is not exactly true because the
range of integers that can be returned via sizeof(character-array) is
limited.<span style="mso-spacerun: yes">  </span>This forces us to use two
vector elements in some cases.<span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The encoding now might look like this (assuming ID of 21):</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class V, <span class=NewCode>class</span> P0, <span
class=NewCode2>unsigned int</span> P1&gt; </p>

<p class=Code>struct encode_type&lt;V, x&lt;P0, P1&gt; &gt;</p>

<p class=Code>{</p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef typename
mpl::push_back&lt;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>V, </p>

<p class=Code><span style="mso-spacerun: yes">    </span>mpl::int_&lt;21&gt; </p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;::type v0;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes"> 
</span>typedef typename encode_type&lt;<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes">    </span>v0,<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes">    </span>P0<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes"> 
</span>&gt;::type v1;</span></p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes"> 
</span>typedef typename mpl::push_back&lt;<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes">   
</span>v1,<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes">   
</span>mpl::int_&lt;P1&gt;<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes"> 
</span>&gt;::type v2;</span></p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span style="mso-spacerun: yes">  </span>typedef v2 type;</p>

<p class=Code>};</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>This really begins looking like polymorphism!<span
style="mso-spacerun: yes">  </span>But first we need objects.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Objects are combination of properties.<span
style="mso-spacerun: yes">  </span>When we are talking about the preprocessor,
we can use sequences.<span style="mso-spacerun: yes">  </span>Besides regular
properties we need type information inside objects.<span style="mso-spacerun:
yes">  </span>This type information can later be used for dispatching:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#define TYPE_PARAM (TYPE_PARAM)<o:p></o:p></span></p>

<p class=Code><span class=NewCode2>#define INTEGRAL_PARAM(Type)
(INTEGRAL_PARAM)(Type)<o:p></o:p></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The first “class”, TYPE_PARAM, doesn’t define any
properties.<span style="mso-spacerun: yes">  </span>The only data contained
inside the “object” is the class information, which is used for dispatching,
and can be thought of as an analogue of the vptr.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The second class, INTEGRAL_PARAM, defines the only property,
which is an integral type of the parameter.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Let’s now implement “virtual functions” (note how their
names are formed – this is used in the virtual function call mechanism):</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#define TYPE_PARAM_TYPE(This) class<o:p></o:p></span></p>

<p class=Code><span class=NewCode><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span class=NewCode>#define TYPE_PARAM_ENCODE(This, n)\<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes"> 
</span>typedef typename encode_type&lt;v ## n, P ## n&gt;::type\<o:p></o:p></span></p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes">   
</span>BOOST_PP_CAT(v, BOOST_PP_INC(n))<o:p></o:p></span></p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode2>#define INTEGRAL_PARAM_TYPE(This)
BOOST_PP_SEQ_ELEM(1, This)<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span class=NewCode2>#define INTEGRAL_PARAM_ENCODE(This, n)\<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes"> 
</span>typedef typename mpl::push_back&lt;v ## n, mpl::int_&lt;P ## n&gt;
&gt;::type\<o:p></o:p></span></p>

<p class=Code><span class=NewCode2><span style="mso-spacerun: yes">   
</span>BOOST_PP_CAT(v, BOOST_PP_INC(n))<o:p></o:p></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Now we need a virtual function call mechanism:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define VIRTUAL(Fname, This)\</p>

<p class=Code><span style="mso-spacerun: yes"> 
</span>BOOST_PP_SEQ_CAT((BOOST_PP_SEQ_HEAD(This))(_)(Fname))</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>As you can see, the head of the object (sequence) is used
for dispatching.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Now the following:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>VIRTUAL(ENCODE, obj)(obj, 2)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>will expand into either</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>TYPE_PARAM_ENCODE(obj, 2)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>or </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>INTEGRAL_PARAM_ENCODE(obj, 2),</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>depending of what the “class” of obj is.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Before we can finish conversion of our encode_type
specialization, we need to transform </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>(class)(unsigned int) </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>into</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>(TYPE_PARAM)(INTEGRAL_PARAM(unsigned int))</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Without going into too much detail, here is an example of
transformation sequence:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>unsigned int <span style='font-family:Wingdings;mso-ascii-font-family:
"Courier New";mso-hansi-font-family:"Courier New";mso-char-type:symbol;
mso-symbol-font-family:Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:
Wingdings'>à</span></span> PREFIX_unsigned int_SUFFIX <span style='font-family:
Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> (unsigned)(int) <span
style='font-family:Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:
"Courier New";mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span
style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span>
MACRO_unsigned_int <span style='font-family:Wingdings;mso-ascii-font-family:
"Courier New";mso-hansi-font-family:"Courier New";mso-char-type:symbol;
mso-symbol-font-family:Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:
Wingdings'>à</span></span> INTEGRAL_PARAM(unsigned int)</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>class <span style='font-family:Wingdings;mso-ascii-font-family:
"Courier New";mso-hansi-font-family:"Courier New";mso-char-type:symbol;
mso-symbol-font-family:Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:
Wingdings'>à</span></span> PREFIX_class_SUFFIX <span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> (class) <span
style='font-family:Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:
"Courier New";mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span
style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span>
MACRO_class <span style='font-family:Wingdings;mso-ascii-font-family:"Courier New";
mso-hansi-font-family:"Courier New";mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span>
TYPE_PARAM</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Assuming this transformation is done with the macro called
TRANSFORM_PARAMS, we can define our encoding specialization like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define REGISTER_TEMPLATE_PARAM_PAIR(z, n, elem) \</p>

<p class=Code><span style="mso-spacerun: yes">    </span>VIRTUAL(TYPE,
elem)(elem) BOOST_PP_CAT(P, n)</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define REGISTER_TEMPLATE_ENCODE_PARAM(r, data, n, elem)\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>VIRTUAL(ENCODE,
elem)(elem, n)</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define REGISTER_TEMPLATE_IMPL(Name, ID, Params, Size)\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>. . . </p>

<p class=Code><span style="mso-spacerun: yes">  </span>template&lt;class V\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>SEQ_ENUM_TRAILING(Params, REGISTER_TEMPLATE_PARAM_PAIR)\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>struct
encode_type_impl&lt;V, Name&lt;BOOST_PP_ENUM_PARAMS(Size, P)&gt; &gt;\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>{\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>typedef typename
mpl::push_back&lt;V, mpl::int_&lt;ID&gt; &gt;::type V0;\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>BOOST_PP_SEQ_FOR_EACH_I(REGISTER_TEMPLATE_ENCODE_PARAM, ~, Params)\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>typedef BOOST_PP_CAT(V,
Size) type;\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>};\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>. . .</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define REGISTER_TEMPLATE(Name, Params)\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>REGISTER_TEMPLATE_IMPL(\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>Name,\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>UNIQUE_ID,\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>TRANSFORM_PARAMS(Params),\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>BOOST_PP_SEQ_SIZE(Params))</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>(SEQ_ENUM_TRAILING is our own macro with, hopefully, obvious
meaning)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The library also supports the third template parameter type,
template template parameters.<span style="mso-spacerun: yes">  </span>Let’s now
take a look at how it’s done. </p>

<h1><a name="_Toc102142303"></a><a name="_Toc100200542"><span style='mso-bookmark:
_Toc102142303'>Template template parameters</span></a></h1>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The good news is
that templates already have unique integer Ids, which are assigned to them
during the registration.<span style="mso-spacerun: yes">  </span>Placing this
Id into the encoding sequence, and then restoring the template from this Id is
all that needs to be done.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Unfortunately,
templates, although strange it might sound, are not the first-class citizens in
template metaprogramming.<span style="mso-spacerun: yes">  </span>True, a
template can be passed into a metafunction, as a template template parameter,
but it turns out to be not very convenient.<span style="mso-spacerun: yes"> 
</span>Also, a template can never be returned as a result of a metafunction.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The Typeof library
solves this problem by converting templates into types.<span
style="mso-spacerun: yes">  </span>It does this by instantiating templates with
well-known dummy types and values – int for type parameters, and zero for
integrals.<span style="mso-spacerun: yes">  </span>Such type is used to move
the template around, and later the template gets extracted using partial
template specialization (this approach is somewhat similar to one used by MPL
to convert metafunctions into metafunction classes).<span style="mso-spacerun:
yes">  </span>For example, consider the std::pair class template.<span
style="mso-spacerun: yes">  </span>Its type representation would be
std::pair&lt;int, int&gt;.<span style="mso-spacerun: yes">  </span>The
following code might then be used to extract the template:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class T&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct extract; // not
defined</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;template&lt;class,
class&gt; class Tpl, class T1, class T2&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct extract&lt;Tpl&lt;T1,
T2&gt; &gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span style='mso-tab-count:
1'>     </span>typedef Tpl&lt;T1*, T2*&gt; type; /* use Tpl in any way you want
*/</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>};</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Armed with this
approach, let’s go back to our template template parameters.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Let’s declare a
metafunction to encode a template:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class V,
class T&gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct encode_template;
// not defined</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Note that it
accepts a type rather than a template.<span style="mso-spacerun: yes"> 
</span>This type is the instantiation of the template that was discussed just a
moment ago.<span style="mso-spacerun: yes">  </span>Hadn’t we used this
approach, it wouldn’t have been possible to declare this:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class V,
template&lt;<b>???</b>&gt; class Tpl&gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct encode_template;
// not defined</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Now let us provide
the specialization for std::pair:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class V,
class P0, class P1&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct encode_template
&lt;V, std::pair&lt;P0, P1&gt; &gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>: mpl::push_back&lt;V, mpl::int_&lt;3&gt;
&gt; /* we still use 3 as an Id of std::pair */</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{}; </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Similarly, let’s
implement decoding:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class T,
class Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct
decode_template_impl; // not defined</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class
Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct decode_template :
decode_template_impl&lt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typename mpl::deref&lt;Iter&gt;::type, </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typename mpl::next&lt;Iter&gt;::type</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>&gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{};</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class
Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct
decode_template_impl&lt;mpl::int_&lt;3&gt;, Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef int P0; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef std::pair&lt;int, int&gt; type; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef Iter iter; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>}; </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>As you can see, the
iterator is de-referenced to determine the Id, which is used to match against a
template specialization.<span style="mso-spacerun: yes">  </span>The template
specialization for std::pair’s Id returns the std::pair class template by
instantiating it with two ints.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The encode_template
and decode_template_impl specializations are added to REGISTER_TEMPLATE macro,
thus making it possible to use registered templates as template template
parameters.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>We now can encode
and decode templates.<span style="mso-spacerun: yes">  </span>Recall that
earlier we talked about template encoding actually meaning encoding a type,
which is an instantiation of a template.<span style="mso-spacerun: yes"> 
</span>Let’s now return to the template encoding in this sense, and see how we
can add template template parameters support.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Let’s assume we
have the following template definition:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class T,
template &lt;class&gt; class Tpl&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct B</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{};</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>If its ID happens
to be 15, its encoding specialization will look like following:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class V, <span
class=NewCode>class</span> P0, <span class=NewCode3>template&lt;class&gt; class</span>
P1&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct encode_type&lt;V,
B&lt;P0, P1&gt; &gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef typename mpl::push_back&lt;V,
mpl::int_&lt;15&gt; &gt;::type V0; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode><span
style="mso-spacerun: yes">    </span>typedef typename encode_type&lt;V0,
P0&gt;::type V1; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode3><span
style="mso-spacerun: yes">    </span>typedef typename encode_template&lt;V1,
P1&lt;int&gt; &gt;::type V2;<span style="mso-spacerun: yes">   </span><o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef V2 type; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>}; </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes"> </span></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The decoding
specialization will be:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>template&lt;class
Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>struct decode_type_impl&lt;mpl::int_&lt;15&gt;,
Iter&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>{</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef Iter iter0; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode><span
style="mso-spacerun: yes">    </span>typedef decode_type&lt;iter0&gt; d0; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode><span
style="mso-spacerun: yes">    </span>typedef typename d0::type P0; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode><span
style="mso-spacerun: yes">    </span>typedef typename d0::iter iter1; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode3><span
style="mso-spacerun: yes">    </span>typedef decode_template&lt;iter1&gt; d1; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode3><span
style="mso-spacerun: yes">    </span>typedef typename d1::type P1; <o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode3><span
style="mso-spacerun: yes">    </span>typedef typename d1::iter iter2;<span
style="mso-spacerun: yes">   </span><o:p></o:p></span></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef typename B&lt;<span class=NewCode>P0</span>,
<span class=NewCode3>???</span>&gt;::type type; /* need to do something else */
</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef iter2 iter; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'>}; </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The only missing
piece is how to instantiate B.<span style="mso-spacerun: yes">  </span>Its
second parameter is a template, but we have a type (which is an instantiation
of the needed template with dummy parameters).</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>As we discussed in
the beginning of this section, we have to use partial template specialization
to extract the template.<span style="mso-spacerun: yes">  </span>The commented
line in the above code can be replaced with the following code:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>. . .</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>template&lt;class T0, class T1&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>struct decode_params; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>template&lt;<span class=NewCode>class</span>
T0, <span class=NewCode3>template &lt;class&gt; class</span> T1&gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>struct decode_params&lt;<span
class=NewCode>T0</span>, <span class=NewCode3>T1&lt;int&gt;</span> &gt; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>{</span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">        </span>typedef B&lt;T0, T1&gt; type; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>}; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>typedef typename decode_params&lt;P0,
P1&gt;::type type; </span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span
style="mso-spacerun: yes">    </span>. . .</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>Note how
decode_params extracts the template from its second parameter, and uses it when
defining the resulting type.<span style="mso-spacerun: yes">  </span>The first
parameter, on the other hand, is a type, and therefore passed through
decode_params as is.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>The code discussed
in this section is generated as a result of the expansion of the
REGISTER_TEMPLATE macro.<span style="mso-spacerun: yes">  </span>The code
specific to template template parameters (green) is handled by the third
polymorphic “class” – TEMPLATE_PARAM, whose only property is a sequence that
describes parameters of the template:</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-bookmark:_Toc100200542'><span class=NewCode3>#define
TEMPLATE_PARAM(Params) (TEMPLATE_PARAM)(Params)<o:p></o:p></span></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc100200542'>With three
“classes” and half a dozen “virtual functions” such plymorphic approach really
pays off.<span style="mso-spacerun: yes">  </span></span></p>

<h1><span style='mso-bookmark:_Toc100200542'><a name="_Toc102142304">Handling
unused sequence elements</a></span></h1>

<p class=MsoNormal>Let’s revisit our TYPEOF macro implementation.<span
style="mso-spacerun: yes">  </span>We left it in the following state:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T, class N&gt; </p>

<p class=Code>char(&amp; at(const T&amp;, const N&amp;) )[</p>

<p class=Code style='text-indent:.5in'>mpl::at&lt;encode_type&lt;T&gt;::type,
N&gt;::type::value</p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=Code style='text-indent:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define TYPEOF(expr)\</p>

<p class=Code style='text-indent:.5in'>decode_type&lt;mpl::vector&lt;\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;0&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;1&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;2&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>…\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;N&gt;()))&gt;\</p>

<p class=Code style='text-indent:.5in'>&gt; &gt;::type</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Considering a few things discussed in the previous section,
we should now rewrite it like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T, class N&gt; </p>

<p class=Code>char(&amp; at(const T&amp;, const N&amp;) )[</p>

<p class=Code style='text-indent:.5in'>mpl::at&lt;encode_type&lt;<span
class=NewCode>mpl::vector0&lt;&gt;, </span>T&gt;::type, N&gt;::type::value</p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=Code style='text-indent:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define TYPEOF(expr)\</p>

<p class=Code style='text-indent:.5in'>decode_type&lt;<span class=NewCode>mpl::begin&lt;</span>mpl::vector&lt;\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;0&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;1&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;2&gt;()))&gt;,\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>…\</p>

<p class=Code><span style='mso-tab-count:2'>          </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;N&gt;()))&gt;\</p>

<p class=Code style='text-indent:.5in'>&gt;<span class=NewCode>::type</span>&gt;::type</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>We don’t want the function template at() to be instantiated
for N greater than the size of the encoded vector for at least two reasons:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:.25in;text-indent:-.25in;mso-list:l0 level1 lfo4;
tab-stops:list .25in'><![if !supportLists]>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>Unnecessary template instantiations have a negative effect on
compile-time performance;</p>

<p class=MsoNormal style='margin-left:.25in;text-indent:-.25in;mso-list:l0 level1 lfo4;
tab-stops:list .25in'><![if !supportLists]>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>mpl::at&lt;&gt; will fail.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>So, let’s start with determining the size of the encoded
vector:<span class=NewCode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'><o:p></o:p></span></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T&gt; </p>

<p class=Code>char(&amp; size(const T&amp;) )[</p>

<p class=Code style='text-indent:.5in'>mpl::size&lt;encode_type&lt;mpl::vector0&lt;&gt;,
T&gt;::type&gt;::type::value</p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Now, for the N greater than the size of the encoded vector,
we will simply substitute zero for N, thus reusing the instantiation of at()
that returns the first element of the encoded sequence:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>mpl::int_&lt;sizeof(at(expr, mpl::int_&lt;<span class=NewCode>(i
&lt; sizeof(size(expr)) ? </span>i<span class=NewCode> : 0)</span>&gt;()))&gt;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Let’s define the encoded vector size limit, and put
everything tohether:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code><span class=NewCode>#ifndef BOOST_TYPEOF_LIMIT_SIZE<o:p></o:p></span></p>

<p class=Code><span class=NewCode>#<span style="mso-spacerun: yes"> 
</span>define BOOST_TYPEOF_LIMIT_SIZE 50<o:p></o:p></span></p>

<p class=Code><span class=NewCode>#endif<o:p></o:p></span></p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T, class N&gt; </p>

<p class=Code>char(&amp; at(const T&amp;, const N&amp;) )[</p>

<p class=Code style='text-indent:.5in'>mpl::at&lt;encode_type&lt;mpl::vector0&lt;&gt;,
T&gt;::type, N&gt;::type::value</p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=Code style='text-indent:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class T&gt; </p>

<p class=Code>char(&amp; size(const T&amp;) )[</p>

<p class=Code style='text-indent:.5in'>mpl::size&lt;encode_type&lt;mpl::vector0&lt;&gt;,
T&gt;::type&gt;::type::value</p>

<p class=Code style='text-indent:.5in'>];</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>#define TYPEOF(expr)\</p>

<p class=Code><span style="mso-spacerun: yes"> 
</span>decode_type&lt;mpl::begin&lt;mpl::vector&lt;\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>mpl::int_&lt;sizeof(at(expr, mpl::int_&lt;(\</p>

<p class=Code><span style="mso-spacerun: yes">      </span><span class=NewCode>0
&lt; sizeof(size(expr)) ? 0 : 0</span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>)&gt;()))&gt;,\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>mpl::int_&lt;sizeof(at(expr,
mpl::int_&lt;(\</p>

<p class=Code><span style="mso-spacerun: yes">      </span><span class=NewCode>1
&lt; sizeof(size(expr)) ? 1 : 0</span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>)&gt;()))&gt;,\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>mpl::int_&lt;sizeof(at(expr, mpl::int_&lt;(\</p>

<p class=Code><span style="mso-spacerun: yes">      </span><span class=NewCode>2
&lt; sizeof(size(expr)) ? 2 : 0</span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>)&gt;()))&gt;,\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>. . .\</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>mpl::int_&lt;sizeof(at(expr, mpl::int_&lt;(\</p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes">     
</span>BOOST_TYPEOF_LIMIT_SIZE &lt; sizeof(size(expr)) ?</span>\ </p>

<p class=Code><span class=NewCode><span style="mso-spacerun: yes">     
</span>BOOST_TYPEOF_LIMIT_SIZE : 0</span>\</p>

<p class=Code><span style="mso-spacerun: yes">    </span>)&gt;()))&gt;,\</p>

<p class=Code><span style="mso-spacerun: yes">  </span>&gt;::type&gt;::type</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>It’s now trivial for anybody familiar with the Boost
Preprocessor Library to re-write this nicely, so let’s omit this.<span
style="mso-spacerun: yes">  </span>You can always see the result at boost/typeof/compliant/typeof_impl.hpp.</p>

<h1><a name="_Toc100200543"></a><a name="_Toc102142305"><span style='mso-bookmark:
_Toc100200543'>A word about complexity</span></a></h1>

<p class=MsoNormal>Looking at the resulting TYPEOF macro, it may seem that the
type of our expression is encoded many times, since functions size() and at()
are mentioned BOOST_TYPEOF_LIMIT_SIZE times each.<span style="mso-spacerun:
yes">  </span>However, the template encode_type&lt;mpl::vector0&lt;&gt;, T&gt;
is always same for the same expression, so it is instantiated only once, and
then just looked up.<span style="mso-spacerun: yes">  </span>Hence, we can
roughly state that the compile-time complexity of our TYPEOF is O(m), where m
is the size of the encoded vector.<span style="mso-spacerun: yes">  </span>In
practice this means that TYPEOF compiles slowly for more complicated types than
for simple types.<span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Copyright © Arkadiy Vertleyb, 2005<span style="mso-spacerun:
yes">   </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

</div>

</body>

</html>
